#!/usr/bin/env python3
"""
Advanced Vulnerability Scanner for PyBitMessage
Finds next-level security issues after basic patches
"""

import os
import re
import ast
import sys
from pathlib import Path

class AdvancedSecurityScanner:
    def __init__(self, base_path="src"):
        self.base_path = Path(base_path)
        self.critical_issues = []
        
    def scan_config_injection(self):
        """Scan for configuration injection vulnerabilities"""
        print("üîç Scanning for configuration injection...")
        
        config_patterns = [
            r'config\.(safeGet|get)\s*\(\s*["\']([^"\']+)["\']\s*,\s*["\']([^"\']+)["\']\s*\)',
            r'config\.(safeGet|get)\s*\(\s*["\']([^"\']+)["\']\s*\)'
        ]
        
        for py_file in self.base_path.rglob("*.py"):
            try:
                with open(py_file, 'r') as f:
                    content = f.read()
                    
                for pattern in config_patterns:
                    matches = re.finditer(pattern, content)
                    for match in matches:
                        # Check if config values are used unsafely
                        section = match.group(2) if match.group(2) else "bitmessagesettings"
                        key = match.group(3) if match.group(3) else match.group(2)
                        
                        # Look for unsafe usage of config values
                        lines = content.split('\n')
                        for i, line in enumerate(lines):
                            if key in line and 'config' not in line:
                                if any(unsafe in line for unsafe in ['eval', 'exec', 'open', 'os.system', 'subprocess']):
                                    self.critical_issues.append({
                                        'file': str(py_file),
                                        'line': i+1,
                                        'type': 'CONFIG_INJECTION',
                                        'severity': 'HIGH',
                                        'description': f'Unsafe usage of config value {key}: {line.strip()}'
                                    })
                                    
            except Exception as e:
                continue
    
    def scan_file_operations(self):
        """Scan for unsafe file operations"""
        print("üîç Scanning for file operation vulnerabilities...")
        
        file_ops = ['open(', 'os.rename', 'shutil.copy', 'shutil.move', 'os.remove']
        
        for py_file in self.base_path.rglob("*.py"):
            try:
                with open(py_file, 'r') as f:
                    content = f.read()
                    tree = ast.parse(content)
                
                for node in ast.walk(tree):
                    if isinstance(node, ast.Call):
                        # Check file operations with user input
                        if isinstance(node.func, ast.Name):
                            if node.func.id == 'open':
                                for arg in node.args:
                                    if isinstance(arg, ast.Name):
                                        # Variable used in file open - potential path traversal
                                        self.critical_issues.append({
                                            'file': str(py_file),
                                            'line': node.lineno,
                                            'type': 'FILE_TRAVERSAL',
                                            'severity': 'MEDIUM',
                                            'description': f'File operation with variable: {ast.unparse(node)}'
                                        })
                                        
            except Exception as e:
                continue
    
    def scan_network_parsing(self):
        """Scan for network protocol parsing vulnerabilities"""
        print("üîç Scanning for network parsing vulnerabilities...")
        
        network_files = list(self.base_path.rglob("network/*.py"))
        
        for py_file in network_files:
            try:
                with open(py_file, 'r') as f:
                    content = f.read()
                    
                # Check for buffer operations without bounds checking
                if 'recv(' in content and ('struct.unpack' in content or 'unpack(' in content):
                    lines = content.split('\n')
                    for i, line in enumerate(lines):
                        if 'recv(' in line and 'struct.unpack' in content[i:i+10]:
                            self.critical_issues.append({
                                'file': str(py_file),
                                'line': i+1,
                                'type': 'NETWORK_PARSING',
                                'severity': 'MEDIUM',
                                'description': 'Network data parsing without explicit bounds checking'
                            })
                            
            except Exception as e:
                continue
    
    def scan_message_processing(self):
        """Scan for message processing vulnerabilities"""
        print("üîç Scanning for message processing vulnerabilities...")
        
        message_patterns = [
            'processMessage', 'handleMessage', 'parseMessage', 'decodeMessage'
        ]
        
        for pattern in message_patterns:
            for py_file in self.base_path.rglob("*.py"):
                try:
                    with open(py_file, 'r') as f:
                        content = f.read()
                        
                    if pattern in content:
                        # Check for complex message parsing logic
                        lines = content.split('\n')
                        for i, line in enumerate(lines):
                            if pattern in line:
                                # Look for potential issues in nearby code
                                context_start = max(0, i-5)
                                context_end = min(len(lines), i+10)
                                context = '\n'.join(lines[context_start:context_end])
                                
                                if any(risk in context for risk in ['eval', 'exec', 'pickle', 'marshal']):
                                    self.critical_issues.append({
                                        'file': str(py_file),
                                        'line': i+1,
                                        'type': 'MESSAGE_PROCESSING',
                                        'severity': 'HIGH',
                                        'description': f'Potential unsafe operation in {pattern}'
                                    })
                                    
                except Exception as e:
                    continue
    
    def run_comprehensive_scan(self):
        """Run all security scans"""
        print("üöÄ Starting comprehensive security scan...")
        self.scan_config_injection()
        self.scan_file_operations() 
        self.scan_network_parsing()
        self.scan_message_processing()
        
        print(f"‚úÖ Scan complete. Found {len(self.critical_issues)} potential issues.")
        return self.critical_issues
    
    def generate_detailed_report(self):
        """Generate detailed vulnerability report"""
        if not self.critical_issues:
            print("üéâ No additional critical issues found!")
            return
        
        print("\n" + "="*80)
        print("ADVANCED SECURITY SCAN REPORT")
        print("="*80)
        
        # Group by type
        issues_by_type = {}
        for issue in self.critical_issues:
            issue_type = issue['type']
            if issue_type not in issues_by_type:
                issues_by_type[issue_type] = []
            issues_by_type[issue_type].append(issue)
        
        for issue_type, issues in issues_by_type.items():
            print(f"\nüî¥ {issue_type} Issues: {len(issues)}")
            for issue in issues[:3]:  # Show first 3 of each type
                print(f"   üìç {issue['file']}:{issue['line']}")
                print(f"      {issue['description']}")
                print()

if __name__ == "__main__":
    scanner = AdvancedSecurityScanner()
    issues = scanner.run_comprehensive_scan()
    scanner.generate_detailed_report()
    
    # Save full report
    with open("advanced_security_scan.txt", "w") as f:
        f.write("PyBitMessage Advanced Security Scan Report\n")
        f.write("="*50 + "\n")
        f.write(f"Total issues found: {len(issues)}\n\n")
        
        for issue in issues:
            f.write(f"[{issue['severity']}] {issue['file']}:{issue['line']}\n")
            f.write(f"Type: {issue['type']}\n")
            f.write(f"Description: {issue['description']}\n\n")
    
    print(f"\nüìÑ Full report saved to: advanced_security_scan.txt")
